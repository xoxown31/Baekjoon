uniq = sorted(set(vals))

# BIT 초기화(모두 생존 1)
bit = BIT(n)
for i in range(n):
    bit.add(i, 1)

alive = n
t = 0           # 현재까지 진행된 총 타임(공격 횟수)
prev = 0        # 바로 전 단계의 HP
ans = [0]*n
p = 0           # 현재 공격 시작 포인터(0-based, 살아있는 몬스터를 가리키도록 유지)

# p가 처음부터 죽어있는 경우는 없음. 그래도 방어.
if bit.range_sum(p, p) == 0:
    p = next_alive_after(bit, p)

for v in uniq:
    delta = v - prev            # 이번 레벨까지 각자 추가로 맞아야 할 횟수(>=1)
    # 마지막 라운드 직전 시간
    base = t + (delta - 1) * alive

    # 이번 레벨에서 죽는 몬스터들(HP == v)의 '포인터 기준 순위' 계산
    ranks = []
    sum_p_1 = bit.sum(p-1)
    total_alive = bit.sum(n-1)
    for idx in by_val[v]:
        # idx는 반드시 생존(오름차순 레벨 처리)
        if idx >= p:
            r = bit.sum(idx) - sum_p_1
        else:
            r = (total_alive - sum_p_1) + bit.sum(idx)
        ranks.append((r, idx))

    # 해당 레벨에서의 사망 시간 = base + rank
    # rank는 1..alive 범위. 순서대로 처리해야 하므로 r 오름차순.
    ranks.sort()
    for r, idx in ranks:
        ans[idx] = base + r

    # 이번 레벨 종료 처리: 전원 delta번 맞았으므로 총 시간/포인터/생존자 갱신
    t += delta * alive
    prev = v
    # 죽은 몬스터 제거
    for _, idx in ranks:
        bit.add(idx, -1)
        alive -= 1

    if alive == 0:
        break

    # 포인터 갱신: 시작점 p가 죽었으면 그 다음 생존자로 이동
    if bit.range_sum(p, p) == 0:
        p = next_alive_after(bit, p)
        # (안전) 여전히 -1이면 모두 죽은 것.
        if p == -1:
            break

# ----- Output -----
print("\n".join(map(str, ans)))
